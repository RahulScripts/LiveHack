#pragma version 10
#pragma typetrack false

// smart_contracts.task.contract.MintSimulator.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "total_minted" "total_bought" "total_sold" "whitelist_0" "whitelist_1" "whitelist_2" 0x80
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/task/contract.py:12
    // self.total_minted = UInt64(0)
    bytec_1 // "total_minted"
    intc_0 // 0
    app_global_put
    // smart_contracts/task/contract.py:13
    // self.total_bought = UInt64(0)
    bytec_2 // "total_bought"
    intc_0 // 0
    app_global_put
    // smart_contracts/task/contract.py:14
    // self.total_sold = UInt64(0)
    bytec_3 // "total_sold"
    intc_0 // 0
    app_global_put
    // smart_contracts/task/contract.py:15
    // self.whitelist_0 = arc4.Address()
    bytec 4 // "whitelist_0"
    global ZeroAddress
    app_global_put
    // smart_contracts/task/contract.py:16
    // self.whitelist_1 = arc4.Address()
    bytec 5 // "whitelist_1"
    global ZeroAddress
    app_global_put
    // smart_contracts/task/contract.py:17
    // self.whitelist_2 = arc4.Address()
    bytec 6 // "whitelist_2"
    global ZeroAddress
    app_global_put

main_after_if_else@2:
    // smart_contracts/task/contract.py:3
    // class MintSimulator(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0x600ba0bd 0x43079ef8 0x0bd3888f 0x6d085326 0x22e4c5a0 0xc48f9bef 0x1de74ddd // method "set_whitelist(address,address,address)void", method "mint()bool", method "buy()bool", method "sell()bool", method "get_total_minted()uint64", method "get_total_bought()uint64", method "get_total_sold()uint64"
    txna ApplicationArgs 0
    match main_set_whitelist_route@5 main_mint_route@6 main_buy_route@7 main_sell_route@8 main_get_total_minted_route@9 main_get_total_bought_route@10 main_get_total_sold_route@11

main_after_if_else@14:
    // smart_contracts/task/contract.py:3
    // class MintSimulator(ARC4Contract):
    intc_0 // 0
    return

main_get_total_sold_route@11:
    // smart_contracts/task/contract.py:62
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_sold
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_bought_route@10:
    // smart_contracts/task/contract.py:58
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_bought
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_minted_route@9:
    // smart_contracts/task/contract.py:54
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_minted
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_sell_route@8:
    // smart_contracts/task/contract.py:48
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub sell
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_buy_route@7:
    // smart_contracts/task/contract.py:42
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub buy
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_mint_route@6:
    // smart_contracts/task/contract.py:30
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub mint
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_whitelist_route@5:
    // smart_contracts/task/contract.py:19
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/task/contract.py:3
    // class MintSimulator(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/task/contract.py:19
    // @arc4.abimethod
    callsub set_whitelist
    intc_1 // 1
    return

main_bare_routing@12:
    // smart_contracts/task/contract.py:3
    // class MintSimulator(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.task.contract.MintSimulator.set_whitelist(addr0: bytes, addr1: bytes, addr2: bytes) -> void:
set_whitelist:
    // smart_contracts/task/contract.py:19-25
    // @arc4.abimethod
    // def set_whitelist(
    //     self,
    //     addr0: arc4.Address,
    //     addr1: arc4.Address,
    //     addr2: arc4.Address
    // ) -> None:
    proto 3 0
    // smart_contracts/task/contract.py:26
    // self.whitelist_0 = addr0
    bytec 4 // "whitelist_0"
    frame_dig -3
    app_global_put
    // smart_contracts/task/contract.py:27
    // self.whitelist_1 = addr1
    bytec 5 // "whitelist_1"
    frame_dig -2
    app_global_put
    // smart_contracts/task/contract.py:28
    // self.whitelist_2 = addr2
    bytec 6 // "whitelist_2"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.task.contract.MintSimulator.mint() -> bytes:
mint:
    // smart_contracts/task/contract.py:30-31
    // @arc4.abimethod
    // def mint(self) -> arc4.Bool:
    proto 0 1
    // smart_contracts/task/contract.py:32
    // sender: arc4.Address = arc4.Address(Txn.sender)
    txn Sender
    dup
    // smart_contracts/task/contract.py:34
    // sender == self.whitelist_0 or
    intc_0 // 0
    bytec 4 // "whitelist_0"
    app_global_get_ex
    assert // check self.whitelist_0 exists
    ==
    // smart_contracts/task/contract.py:34-36
    // sender == self.whitelist_0 or
    // sender == self.whitelist_1 or
    // sender == self.whitelist_2
    bnz mint_after_if_else@4
    // smart_contracts/task/contract.py:35
    // sender == self.whitelist_1 or
    intc_0 // 0
    bytec 5 // "whitelist_1"
    app_global_get_ex
    assert // check self.whitelist_1 exists
    frame_dig 0
    ==
    // smart_contracts/task/contract.py:34-36
    // sender == self.whitelist_0 or
    // sender == self.whitelist_1 or
    // sender == self.whitelist_2
    bnz mint_after_if_else@4
    // smart_contracts/task/contract.py:36
    // sender == self.whitelist_2
    intc_0 // 0
    bytec 6 // "whitelist_2"
    app_global_get_ex
    assert // check self.whitelist_2 exists
    frame_dig 0
    ==
    // smart_contracts/task/contract.py:34-36
    // sender == self.whitelist_0 or
    // sender == self.whitelist_1 or
    // sender == self.whitelist_2
    bnz mint_after_if_else@4
    // smart_contracts/task/contract.py:38
    // return arc4.Bool(False)
    pushbytes 0x00
    swap
    retsub

mint_after_if_else@4:
    // smart_contracts/task/contract.py:39
    // self.total_minted += UInt64(1)
    intc_0 // 0
    bytec_1 // "total_minted"
    app_global_get_ex
    assert // check self.total_minted exists
    intc_1 // 1
    +
    bytec_1 // "total_minted"
    swap
    app_global_put
    // smart_contracts/task/contract.py:40
    // return arc4.Bool(True)
    bytec 7 // 0x80
    swap
    retsub


// smart_contracts.task.contract.MintSimulator.buy() -> bytes:
buy:
    // smart_contracts/task/contract.py:44-45
    // # Simulate a buy action (custom logic, e.g., increment a counter)
    // self.total_bought += UInt64(1)
    intc_0 // 0
    bytec_2 // "total_bought"
    app_global_get_ex
    assert // check self.total_bought exists
    intc_1 // 1
    +
    bytec_2 // "total_bought"
    swap
    app_global_put
    // smart_contracts/task/contract.py:46
    // return arc4.Bool(True)
    bytec 7 // 0x80
    retsub


// smart_contracts.task.contract.MintSimulator.sell() -> bytes:
sell:
    // smart_contracts/task/contract.py:50-51
    // # Simulate a sell action (custom logic, e.g., increment a counter)
    // self.total_sold += UInt64(1)
    intc_0 // 0
    bytec_3 // "total_sold"
    app_global_get_ex
    assert // check self.total_sold exists
    intc_1 // 1
    +
    bytec_3 // "total_sold"
    swap
    app_global_put
    // smart_contracts/task/contract.py:52
    // return arc4.Bool(True)
    bytec 7 // 0x80
    retsub


// smart_contracts.task.contract.MintSimulator.get_total_minted() -> bytes:
get_total_minted:
    // smart_contracts/task/contract.py:56
    // return arc4.UInt64(self.total_minted)
    intc_0 // 0
    bytec_1 // "total_minted"
    app_global_get_ex
    assert // check self.total_minted exists
    itob
    retsub


// smart_contracts.task.contract.MintSimulator.get_total_bought() -> bytes:
get_total_bought:
    // smart_contracts/task/contract.py:60
    // return arc4.UInt64(self.total_bought)
    intc_0 // 0
    bytec_2 // "total_bought"
    app_global_get_ex
    assert // check self.total_bought exists
    itob
    retsub


// smart_contracts.task.contract.MintSimulator.get_total_sold() -> bytes:
get_total_sold:
    // smart_contracts/task/contract.py:64
    // return arc4.UInt64(self.total_sold)
    intc_0 // 0
    bytec_3 // "total_sold"
    app_global_get_ex
    assert // check self.total_sold exists
    itob
    retsub
